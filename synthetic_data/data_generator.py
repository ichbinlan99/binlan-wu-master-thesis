import numpy as np
import random
import matplotlib.pyplot as plt


# plt.style.use('seaborn')
class sci:
    '''
    Generating synthetic data for the SCI individual
    Time granularity: the minimum time unit used is tu, which means we
    will take the average within each tu for each signal

    '''

    def __init__(self, tu, n_hrs, tau_max):  # age, gender, weight, loi, ht, tsi, smoke

        '''
        demographic features (background factors)
        '''

        # todo to make the basline dependent of age gender...
        self.tu = tu  # the minimum time unit in mins
        self.n_hrs = n_hrs  # number of hours recorded
        self.tau_max = tau_max  # maximum time lag
        self.tlength = self.n_hrs * 60 * self.tu  # total time span of the observation
        # self.t_start = 0  # starting time of recording
        # self.age = age  # age of the patient in years
        # self.gender = gender  # gender of the patient
        # self.weight = weight  # weight of the patient
        # self.loi = loi  # level of injuries 1-30
        # self.ht = ht  # hypertensive episode
        # self.tsi = tsi  # time since injury in years
        # self.smoke = smoke  # smoking habit 0/1

        '''
        dynamic signals 
        '''

        '''
        activities: 0: transfer; 1: 
        '''
        self.act = np.zeros(self.tlength + self.tau_max)
        # activities recorded of the sci patient encoded as 0-9 from light to heavy
        # 0-sleep; 1-assisted propulsion; 2-using computer; 3-using phone; 4-talking;
        # 5-washing; 6-pressure relief; 7-transfer; 8-self propulsion; 9-exercise
        self.bld = np.zeros(self.tlength + self.tau_max)  # stimulus from bladder distension: 0/1
        self.ad = np.zeros(self.tlength + self.tau_max)  # onsets of autonomic dysreflexia: 0/1
        self.sbp_base = np.random.uniform(90, 110)
        self.sbp = np.full(self.tlength + self.tau_max, self.sbp_base)  # systolic blood pressure
        self.dbp = np.full(self.tlength + self.tau_max, np.random.uniform(50, 60))  # diastolic blood pressure
        self.rr = np.full(self.tlength + self.tau_max, np.random.uniform(12, 20))  # respiration rate
        self.hr_base = np.random.uniform(50, 80)  # heart rate baseline
        self.hr = np.full(self.tlength + self.tau_max, self.hr_base)  # heart rate
        self.bt_base = np.random.uniform(36.2, 36.4)  # body temperature baseline
        self.bt = np.full(self.tlength + self.tau_max, self.bt_base)  # body temperature: Celsius degrees
        self.spo = np.full(self.tlength + self.tau_max, np.random.uniform(85, 90))  # blood oxygen levels .%
        self.eda_base = np.random.uniform(2, 8)
        self.eda = np.full(self.tlength + self.tau_max, self.eda_base)  # records of sweating: 0/1

    def get_signals(self, seed):

        np.random.seed(seed)

        # initialization
        # number of activities and time to switch
        nr_act = 6  # np.random.randint(6,12)
        # print(nr_act)
        switch_pt = np.random.randint(0, self.tlength + self.tau_max, nr_act)
        switch_pt.sort()
        # print(switch_pt)
        self.act[:switch_pt[0]] = 5  # can be hard-fixed to transport --> wash --> ...
        self.act[switch_pt[-1]:] = 9  # np.random.randint(0,10) #can be hard-fixed to wash --> transport --> sleep
        cur_act = None
        for i in range(nr_act - 1):
            temp_act = np.random.randint(0, 10)
            if temp_act == cur_act:
                temp_act = np.random.randint(0, 10)
            self.act[switch_pt[i]:switch_pt[i + 1]] = temp_act
            # bladder distension
        self.bld_filled = random.uniform(250, 420)
        bld_period = 10 * self.tu  # bladder extension last for 60 mins, number of bladder distension is 1 time per recording
        self.bld_pt = [0, self.tlength]
        # todo move nr_bld_pt out
        # bladder volume is generated by first randomly select 2 points from the
        # whole time span(excluding some period in the beginning and end), then interpolate
        # between 0 and the randomly generated max bladder volume to mimic the process of
        # injection and releasing of the bladder
        for i in range(3):
            self.bld_pt.append(np.random.randint(i * self.tlength / 3 + 3 * self.tau_max - self.tu, (
                    i + 1) * self.tlength / 3 + 3 * self.tau_max - self.tu))  # recrording needs to be one hour longer
        self.bld_pt.sort()
        self.bld[self.tlength] = 0
        self.bld[self.bld_pt[-2]] = self.bld_filled
        for i in range(len(self.bld_pt) - 1):
            if i % 2 == 0:
                self.bld[self.bld_pt[i]] = 0
            elif i % 2 != 0:
                self.bld[self.bld_pt[i]] = self.bld_filled
            for j in range(1, self.bld_pt[i + 1] - self.bld_pt[i]):
                if i % 2 == 0:
                    self.bld[j + self.bld_pt[i]] = j * self.bld_filled / (
                            self.bld_pt[i + 1] - self.bld_pt[i]) + np.random.normal(0, 2)
                else:
                    self.bld[j + self.bld_pt[i]] = -(j + self.bld_pt[i] - self.bld_pt[i + 1]) * self.bld_filled / (
                            self.bld_pt[i + 1] - self.bld_pt[i]) + np.random.normal(0, 2)
        # define the criterion of an onset of AD
        self.diff = random.uniform(20, 40)
        seed = 1
        # noise = np.random.normal(0, 0.1)
        for t in range(self.tau_max, self.tlength + self.tau_max):
            self.bt[t] = ar(self.bt, t, 6) + max(0, self.act[t - 1] - self.act[t - 3]) / self.bt[t - 1] - (self.eda[t - 3]-self.eda_base) * min(max(self.bt[t - 1] - self.bt[t - 2], 0), 0.5) * 0.02 + np.random.normal(0, 0.02)
            # ad this is a redundant node as AD is now defined by sbp
            self.ad[t] = indic(self.sbp[t - 1] - self.sbp_base, self.diff)
            # systolic blood pressure
            self.sbp[t] += ar(self.sbp, t, 6) / self.sbp[0] + max(self.act[t - 1] - self.act[t - 3],0) * np.random.normal(2, 1) + (self.bld[t - 4]) * random.uniform(0.15, 0.25) + np.random.normal(0, 3)
            # diastolic blood pressure
            self.dbp[t] += ar(self.dbp, t, 6) / self.dbp[0] + self.act[t - 3] * random.uniform(-2, -1) + (self.bld[t - 4]) * random.uniform(0.15, 0.25) + np.random.normal(0, 3)
            # sweating (eda)
            self.eda[t] += ar(self.eda, t, 4)/ self.eda[0] + (self.bt[t] - self.bt_base)*10 + self.sbp[t] + indic(self.sbp[t - 1] - self.sbp_base, self.diff)*np.random.normal(20, 5)
            # heart rate
            self.hr[t] += ar(self.hr, t, 6) / self.hr[0] + (self.act[t - 2] - self.act[t - 1]) * np.random.normal(1,2) + max(0, (self.sbp[t] - self.sbp_base)) * random.uniform(1, 1.5) + np.random.normal(0, 5)
            # respiration rate
            self.rr[t] += (self.hr[t - 1] - self.hr_base) * random.uniform(0.2, 0.25) + np.random.normal(0, 3)
            # blood oxygen level
            self.spo[t] += self.rr[t - 2] * random.uniform(0.15, 0.25) + np.random.normal(0, 2)

        return {
            "systolic_blood_pressure": self.sbp[self.tau_max:, ],
            "diastolic_blood_pressure": self.dbp[self.tau_max:, ],
            "heart_rate": self.hr[self.tau_max:, ],
            "respiration_rate": self.rr[self.tau_max:, ],
            "body_temperature": self.bt[self.tau_max:, ],
            "oxygen_level": self.spo[self.tau_max:, ],
            "bladder": self.bld[self.tau_max:, ],
            "sweating": self.eda[self.tau_max:, ],
            "activity": self.act[self.tau_max:, ],
        }

    def plot(self, data):
        plt.figure(figsize=(60, 90))
        for i in range(data.shape[1]):
            plt.subplot(data.shape[1], 1, i + 1)
            plt.xlabel('time unit', fontsize=10)
            plt.title(data.columns[i], fontsize=10)
            plt.plot(data.iloc[:, i].values, color=plt.cm.Paired(i), linewidth=3)
        plt.show()


def indic(x, crit):
    if x >= crit:
        return 1
    else:
        return 0


def sig(x):
    return 1 / (1 + np.exp(-x))


def relu(x):
    if x < 0:
        return 0
    else:
        return x


def sgn(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0


def ar(x: list, t, lag):
    total = []
    for i in range(t - lag, t):
        total.append(x[i])
    return np.mean(total)
